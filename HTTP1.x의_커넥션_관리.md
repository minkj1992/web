# HTTP/1.x의 커넥션 관리
> [MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x)

HTML5의 `websocket`을 공부하던 중, HTTP가 커넥션을 어떻게 유지하고 `TCP`와 어떤식으로 상호작용하는지 궁금하여 정리를 하게되었습니다. TLS/1.0, HTTP/2.0 버전을 공부하기 앞서 해당 분야를 먼저 공부하고자 합니다.

- HTTP/1.0 단기 커넥션
- HTTP/1.x 영속적인 커넥션
- HTTP/1.x 파이프라이닝
- HTTP2.0 멀티 플렉싱

명심해야할 점은 HTTP 내 커넥션 관리가 `end-to-end`가 아닌 `hop-by-hop`방식으로 관리가 된다는 점입니다. 여기서 `hop-by-hop`방식은 클라이언트와 프록시 사이, 첫번째 프록시와 두번째 프록시 사이, 프록시와 최종 목적 서버 사이의 관계들을 의미합니다. 즉 각 연결들에 관해서 커넥션 관리 정책이 다르게 적용될 수 있습니다.

![](./img/HTTP1_x_Connections.png)


## 단기 커넥션
> HTTP/1.0의 Default 커넥션


각각의 HTTP 요청은 각각의 커넥션 상에서 실행됩니다. 이는 

1. Connection 헤더가 존재하지 않음
2. Connection 헤더의 값이 `close`

인경우 적용됩니다.

## non-persistent connections

커넥션이 IDLE 상태가 되면 곧바로 닫히는 커넥션입니다.

## 영속적인 커넥션 (Persistent Connection)
> a.k.a `keep-alive 커넥션`

영속적인 커넥션은 얼마간 연결을 열어놓고 여러 요청에 재사용함으로써, 새로운 TCP 핸드셰이크를 하는 비용을 아끼고, TCP의 성능 향상 기능을 활용할 수 있습니다.

커넥션은 영원히 열려있지 않으며 Idle 커넥션들에 대해서는 일정 시간 후에 닫히게 됩니다. (keep-alive에 값을 설정하여 해당 시간을 설정 가능합니다.)

단점은 Idle 상태의 커넥션들에 대해 서버 리소스가 소비되며, 서버가 과부화 상태일 경우 `DoS attacks`를 당할 수 있습니다. 이에 대해서는 `non-persistent connections`를 사용하는 것이 더 나은 방법입니다.

HTTP/1.0에서는

1. `Connection`을 `Close`가 아닌 다른, 일반적으로 `retry-after`를 설정하여 사용가능

HTTP/1.1에서는

기본적으로 영속적이며 헤더도 필요하지 않습니다. 그러나 HTTP/1.0으로 동작하는 경우(fallback)에 대비하기 위해 종종 추가하기도 합니다.


## HTTP 파이프라이닝
> HTTP/2에서 사용되는 멀티플렉싱 방법이 더욱 좋은 방식

**기본적으로, HTTP 요청은 순차적입니다.** 현재의 요청에 대한 응답을 받고 나서야 다음 요청을 실시합니다. 네트워크 지연과 대역폭 제한에 걸려 다음 요청을 보내는 데까지 상당한 딜레이가 발생할 수 있습니다.

파이프라이닝이란 같은 영속적인 커넥션을 통해서, 응답을 기다리지 않고 요청을 연속적으로 보내는 기능입니다. 이것은 **커넥션의 지연를 회피하고자 하는 방법**입니다

이론적으로는, 두 개의 HTTP 요청을 하나의 TCP 메시지 안에 채워서(be packed) 성능을 더 향상시킬 수 있습니다. HTTP 요청의 사이즈는 지속적으로 커져왔지만, 일반적인 MSS(최대 세그먼트 크기)는 몇 개의 간단한 요청을 포함하기에는 충분히 여유있습니다.

모든 종류의 HTTP 요청이 파이프라인으로 처리될 수 있는 것은 아닙니다: **GET, HEAD, PUT 그리고 DELETE 메서드같은 idempotent 메서드만 가능합니다**. 실패가 발생한 경우에는 단순히 파이프라인 컨텐츠를 다시 반복하면 됩니다.

오늘날, 모든 HTTP/1.1 호환 프록시와 서버들은 파이프라이닝을 지원해야 하지만, 실제로는 많은 프록시와 서버들은 제한을 가지고 있습니다. 모던 브라우저가 이 기능을 기본적으로 활성화하지 않는 이유입니다.

해당 문제는 `HOL Blocking`문제라고 칭하며 이에 대해 좀 더 설명하자면: 순차적으로 데이터를 요청하고 받아야 하다 보니 먼저 받은 요청이 끝나지 않으면 그 뒤에 있는 요청의 처리가 아무리 빨리 끝나도 먼저 온 요청이 끝날 때까지 기다려야 합니다. 이를 HTTP의 HOL(Head Of Line) Blocking 문제라고 하고 파이프라이닝의 큰 문제입니다.