# CGI, FastCGI와 WSGI
> https://show-me-the-money.tistory.com/50
> https://brownbears.tistory.com/350


## CGI의 등장
정적으로 동작하는 웹서버는 한계가 있다. 이를 해결해주기 위해서 다양한  `dynamic`기능을 필요로 하는 `request`들을 처리하기 위해 데이터베이스, 다양한 계산을 하는 프로그램 스크립트들(python, java, c 등)과 통신을 하여 이를 해결해 주기 위해서 `CGI` 인터페이스가 등장하였다.

CGI는 인터페이스로 특정 플랫폼에 의존하지 않고, 웹 서버로부터 외부 프로그램을 호출하는 방식을 정의해 놓은 프로토콜이다. CGI의 주요한 한계점은 데이터 처리 요청이 있을 때마다 매번 `프로세스`를 `fork()`하여 처리를 하였는데, 이 같은 성질 때문에 성능과 확장성에서 한계가 발생하였다.

## Fast CGI
이를 해결하기 위해 `Fastcgi`가 등장하였다. `Fastcgi`는 각각의 요청에 새로운 프로세스를 생성하는 것이 아니라 하나의 프로세스에서 여러 요청을 처리하는 방식으로, CGI가 웹서버에 의해 프로세스가 관리되던 것과 상반되게 `Fastcgi 서버`가 프로세스를 관리 한다.

## Fast CGI vs Servlet

서블릿 API는 웹 서버를 Java로 작성하고 애플리케이션을 직접 호출 할 수있는 "이점"을 제공하기 때문에 `FastCGI`처럼 low level에서 os에 프로세스를 동작하는 byte-protocol이 필요하지 않다. Java는 언어 특성상 JVM 기반에서 동작하기 때문에 그렇다.

Java 개발자는 Java를 실행하는 것을 선호하므로 서블릿이 표준이며, 이는 Java 언어에 구속된다는 단점이 있는 대신 개발의 편의성을 증진 시킬 수 있다. 반면 FastCGI는 저수준에서 동작하기 때문에 다양한 웹 서버 환경에서 운용이 가능하지만, 생산성은 떨어질 수 있다.

## Fast CGI 요청 처리
1. 클라이언트 `request` -> 웹서버
2. 웹서버에서 `socket`, `TCP`연결을 통해 `Fastcgi 프로세스`(서버)에게 `환경변수`, `request`를 전달
3. Fastcgi 프로그램이 다른 프로그램을 호출하여 reqeust에 필요한 데이터를 생산
4. socket을 통해 웹서버로 응답 전달
5. 웹서버는 HTML 문서를 만들어 client에게 `response`
6. 응답이 종료 되었어도, 웹서버와 FastCGI 서버와의 연결은 지속된다.

## FastCGI 장단점
FastCGI는 서버를 분리해서 사용가능하기 때문에 가용성이 뛰어나며 분산처리가 가능하다는 장점이 있지만, 서버와의 연결되고 있는 FastCGI 프로세스가 종료되지 않고 처리를 위해 계속 상주하고 있는 형태이기 때문에 CGI보다 메모리 소비가 크다는 단점이 있다.

FastCGI방식이외에도 mod-perl, mod-php, mod-python처럼 웹서버에 내장 인터프리터로 동작하는 방식도 있다. 이렇게 하는 경우 내장된 언어를 웹서버가 해석할 수 있기 때문에 해당 언어로 서버 프로그래밍하는 것이 가능하다는 장점이 있다.

## WSGI가 등장하게 된계기
> 앞선 방식들의 문제점

보통 CGI, FastCGI, mod_python과 같은 커스텀 API중 하나만 사용할 수 있도록 디자인 되었습니다. 하지만 이들은 각각 문제점을 가지고 있었습니다.

- CGI는 요청마다 프로세스를 생성하기 때문에 성능과 확장성에 한계가 존재했습니다.

- mod_python은 웹서버 내부에 python 번역기를 달아 사용하므로 편하게 서버 프로그래밍을 할 수 있을 것이라 생각되었습니다.
번역기가 내장되어 있기 때문에 CGI와는 달리 매 요청마다 Python interpreter를 시작할 필요가 없습니다. 이러한 장점에도 불구하고 이것을 사용하기에 몇가지 문제점이 존재했습니다.
PHP interpreter와는 별개로 Python Interpreter는 파일을 실행할 때 캐싱을 사용합니다. 따라서 파일의 내용이 바뀌면 웹 서버가 재시작 되어야 하는 불편함이 존재했습니다.
대중적인 Apache 웹서버의 경우 child process가 요청을 핸들링합니다. 하지만 모든 child process들이 python interpreter 전체를 로드해야만 사용이 가능했습니다. 이것때문에 웹서버 성능 저하가 이슈가 발생하게 되었습니다.
mod_python은 특정 버전의 libpython에 의존적이었습니다. 따라서 python 구버전에서 새로운 버전으로 사용하기가 힘듭니다. 사용하려면 mod_python을 컴파일을 다시 해야하는 불편함이 존재했습니다.

- FastCGI와 SimpleCGI는 CGI의 성능 개선을 위해서 등장했습니다.
웹서버에서 떨어져 나와 백그라운드 프로세스를 계속 돌려놓는 방식으로 동작합니다.
웹서버와 분리되기 때문에 안정적이고 어떤 언어로든 구현할 수 있습니다. 그리고 요청마다 프로세스를 생성하는 기존의 방식이 아니기에 성능면에서도 뛰어납니다.
여전히 CGI와 호환되는 프로그램을 작성하는 것이 가능하지만 권장되는 방식은 아닙니다.

WSGI는 위에서 처럼 웹서버가 호출하는 프로그램으로 Python을 사용하기가 조금 힘들다는 점을 해결하려고 나온 인터페이스입니다.

## WSGI
앞에서 살펴봤듯이 웹서버가 프로그램과 상호작용하는 여러가지 방식들이 있습니다.(CGI, Fast CGI, mod_python) 하지만 이들의 통신 방식은 python의 여러 프레임워크마다 그리고 흔히 Proxy로 사용하는 웹서버마다 다르게 정의되었습니다. 이러한 웹서버와 python application간의 통신 방식에 존재하는 종속성을 없애기 위해 표준을 정의한 것이 바로 WSGI입니다.

WSGI는 웹서버의 선택과 프레임워크 선택을 분리할 수 있도록 웹서버와 Python application간에 표준화된 통신 인터페이스를 정의한 것입니다. **WSGI 서버라고 부르는 것들은 Python App과 웹서버(e.g. Nginx, Apache)를 연결해주는 역할을 합니다.**

그리고 WSGI 표준대로 웹서버와 python application간의 다리 역할을 해줄 수 있는 구현체가 `WSGI 서버`입니다. Python은 테스팅용으로 내부적으로 wsgiref라는 WSGI 서버를 가지고 있습니다. 대표적인 WSGI 서버는 flup, gunicorn, uwsgi등이 존재합니다.
